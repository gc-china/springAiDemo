# 生产级监控与告警系统实施计划

## 目标
构建企业级监控与告警体系，覆盖 Redis 会话层的所有关键指标，支持实时监控、历史分析和智能告警。

---

## 一、架构设计

### 监控链路
```
Spring Boot Application
    ↓
Micrometer（指标收集）
    ↓ (PULL)
Prometheus（时序数据库）
    ↓
Grafana（可视化）
    ↓
AlertManager（告警路由）
    ↓
通知渠道（钉钉/飞书/PagerDuty/Email）
```

### 核心组件
1. **Micrometer**: Spring Boot 官方指标库，提供统一抽象
2. **Prometheus**: 时序数据库，拉取模式（Pull）
3. **Grafana**: 可视化平台，支持多数据源
4. **AlertManager**: 告警管理，支持分组、抑制、静默

---

## 二、监控指标体系

### 2.1 Redis 写入延迟（P50/P95/P99）

**指标名称**: `redis_session_write_duration_seconds`

**类型**: Timer（分位数 + 总数 + 总耗时）

**标签**:
- `operation`: `save_message` | `create_session` | `delete_session`
- `conversation_id`: 会话ID（可选，高基数需要考虑）

**采集点**: `RedisSessionMemoryServiceImpl.saveMessage()`

**告警阈值**:
- **WARNING**: P95 > 50ms
- **CRITICAL**: P99 > 100ms 或 P95 > 80ms

---

### 2.2 Stream Lag（消费延迟）

**指标名称**: `redis_stream_consumer_lag`

**类型**: Gauge（瞬时值）

**标签**:
- `stream_key`: `session:global-stream`
- `consumer_group`: `archiver`
- `consumer_name`: `consumer-1`

**计算方式**:
```java
Lag = Stream当前长度 - Consumer已处理的Entry数量
```

**采集点**: `SessionEventConsumer` 每次消费后更新

**告警阈值**:
- **WARNING**: Lag > 1000
- **CRITICAL**: Lag > 5000 或持续增长

---

### 2.3 归档失败率

**指标名称**: 
- `session_archive_total` (Counter)
- `session_archive_failed_total` (Counter)

**类型**: Counter（累计值）

**标签**:
- `status`: `success` | `failed` | `retry`
- `failure_reason`: `db_error` | `timeout` | `validation_error`

**计算失败率**:
```promql
rate(session_archive_failed_total[5m]) / rate(session_archive_total[5m]) * 100
```

**告警阈值**:
- **WARNING**: 失败率 > 1%
- **CRITICAL**: 失败率 > 5% 或连续失败 > 10次

---

### 2.4 Token 使用监控

**指标名称**: `session_token_usage_total`

**类型**: Counter（累计）

**标签**:
- `role`: `user` | `assistant` | `system`
- `model`: `qwen-max`

**采集点**: `AiService.processQuery()` 保存消息时

**告警阈值**:
- **WARNING**: 每小时 Token 使用量突增 > 50%
- **CRITICAL**: 每日 Token 成本 > 预算

---

### 2.5 会话级监控

**指标名称**:
- `session_active_count` (Gauge): 活跃会话数
- `session_total_messages` (Counter): 总消息数
- `session_ttl_expired_total` (Counter): 过期会话数

**标签**:
- `status`: `active` | `archived` | `deleted`

**告警阈值**:
- **WARNING**: 活跃会话数突增 > 200%
- **CRITICAL**: 系统内存占用 > 80%

---

### 2.6 JVM 与系统指标（Spring Boot Actuator 内置）

- `jvm_memory_used_bytes`: JVM 内存使用
- `jvm_gc_pause_seconds`: GC 暂停时间
- `system_cpu_usage`: CPU 使用率
- `process_uptime_seconds`: 应用运行时长

---

## 三、实施步骤

### 第一步：添加依赖

```xml
<!-- Micrometer Prometheus Registry -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>

<!-- Spring Boot Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

### 第二步：配置 Actuator 端点

**application.yml**:
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
      base-path: /actuator
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      env: production
    distribution:
      percentiles-histogram:
        http.server.requests: true
        redis.session.write.duration: true
```

### 第三步：创建自定义指标服务

**文件**: `SessionMetricsService.java`

**功能**:
- 封装所有自定义指标的注册和更新
- 提供类型安全的指标操作方法
- 支持标签动态注入

### 第四步：在业务代码中埋点

**埋点位置**:
1. `RedisSessionMemoryServiceImpl.saveMessage()` - 写入延迟
2. `SessionEventConsumer.onMessage()` - Stream Lag
3. `DBSessionArchiver.archive()` - 归档成功/失败
4. `AiService.processQuery()` - Token 使用

### 第五步：配置 Prometheus 抓取

**prometheus.yml**:
```yaml
scrape_configs:
  - job_name: 'spring-aidemo'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:8888']
        labels:
          env: 'production'
          service: 'ai-agent'
```

### 第六步：创建 Grafana Dashboard

**Dashboard 包含**:
1. **Overview Panel**: 总览（QPS、错误率、延迟）
2. **Redis Panel**: 写入延迟分位数图、连接池状态
3. **Stream Panel**: Lag趋势图、消费速率
4. **Archive Panel**: 归档成功率、失败TOP原因
5. **Token Panel**: Token使用趋势、成本预估
6. **JVM Panel**: 内存、GC、线程

### 第七步：配置 AlertManager 告警规则

**alerts.yml**:
```yaml
groups:
  - name: redis_session_alerts
    interval: 30s
    rules:
      - alert: HighRedisWriteLatency
        expr: histogram_quantile(0.95, rate(redis_session_write_duration_seconds_bucket[5m])) > 0.05
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Redis写入延迟过高"
          description: "P95延迟 {{ $value }}s，超过50ms阈值"

      - alert: StreamLagTooHigh
        expr: redis_stream_consumer_lag > 1000
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Stream消费积压严重"
          description: "当前Lag: {{ $value }}，需立即处理"

      - alert: ArchiveFailureRateHigh
        expr: rate(session_archive_failed_total[5m]) / rate(session_archive_total[5m]) > 0.05
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "归档失败率超过5%"
```

### 第八步：集成通知渠道

**支持渠道**:
- **钉钉**: Webhook 集成
- **飞书**: Webhook 集成
- **PagerDuty**: API 集成
- **Email**: SMTP 配置

---

## 四、生产级最佳实践

### 4.1 标签策略

**高基数标签避免**:
- ❌ 不要用 `conversation_id` 作为标签（会产生百万级时间序列）
- ✅ 使用聚合维度：`operation` | `status` | `failure_reason`

**标签层级**:
```
application (全局)
  ↓
service (服务级)
  ↓
operation (操作级)
  ↓
status (结果级)
```

### 4.2 指标命名规范

**格式**: `<namespace>_<subsystem>_<name>_<unit>`

**示例**:
- `redis_session_write_duration_seconds`
- `session_archive_failed_total`
- `redis_stream_consumer_lag`

### 4.3 告警收敛

**分级告警**:
- **P0 (Critical)**: 立即人工介入，触发 PagerDuty
- **P1 (Warning)**: 需要关注，发送钉钉/飞书
- **P2 (Info)**: 记录日志，不发送通知

**静默策略**:
- 非工作时间降低告警级别
- 已知维护窗口自动静默

### 4.4 SLO 定义

**可用性 SLO**:
- 目标: 99.9% (月度)
- 错误预算: 43.2分钟/月

**延迟 SLO**:
- P95 < 50ms (Redis 写入)
- P99 < 100ms (Redis 写入)

---

## 五、验证计划

### 5.1 指标验证

```bash
# 1. 访问 Prometheus 端点
curl http://localhost:8888/actuator/prometheus | grep redis_session

# 2. 查询 Prometheus
curl 'http://localhost:9090/api/v1/query?query=redis_session_write_duration_seconds_count'

# 3. 验证 Grafana Dashboard
# 访问: http://localhost:3000
# 导入 Dashboard JSON
```

### 5.2 告警验证

```bash
# 1. 模拟高延迟
# 在 Redis 中执行慢查询

# 2. 模拟 Stream Lag
# 停止消费者，持续写入消息

# 3. 验证告警触发
# 检查 AlertManager UI: http://localhost:9093
```

### 5.3 压力测试

使用 JMeter 或 Gatling:
- 并发 100 用户
- 持续 10 分钟
- 监控所有指标是否正常采集

---

## 六、上线检查清单

### 部署前
- [ ] Prometheus 配置文件已更新
- [ ] Grafana Dashboard 已导入
- [ ] AlertManager 告警规则已配置
- [ ] 通知渠道已测试（钉钉/飞书）
- [ ] SLO 基线已确定

### 上线后
- [ ] 指标采集正常（检查 Prometheus Targets）
- [ ] Dashboard 数据正常显示
- [ ] 告警规则已激活
- [ ] 团队已培训（如何查看Dashboard、如何响应告警）

### 持续运维
- [ ] 每周回顾告警触发情况
- [ ] 每月调整告警阈值
- [ ] 每季度优化 Dashboard

---

## 七、文件清单

### 代码文件
1. `SessionMetricsService.java` - 指标服务
2. `MetricsConfig.java` - Micrometer 配置
3. `AlertController.java` - 告警测试接口（可选）

### 配置文件
1. `application.yml` - Actuator 配置
2. `prometheus.yml` - Prometheus 抓取配置
3. `dashboard.json` - Grafana Dashboard
4. `alerts.yml` - AlertManager 告警规则

### 文档文件
1. `监控与告警实施总结.md` - 实施文档
2. `Runbook.md` - 故障处理手册

---

## 八、成本与收益

### 成本
- **存储**: Prometheus 每个指标约 1-2 bytes/sample，15s采集间隔
  - 估算: 100 个指标 × 86400秒/天 ÷ 15s × 2 bytes ≈ 1.15 MB/天
- **计算**: Grafana 查询消耗 CPU，可忽略
- **运维**: 初期 2-3 人日，后续维护 1 人日/月

### 收益
- **故障发现时间**: 从小时级 → 分钟级
- **平均修复时间(MTTR)**: 减少 60%
- **可用性提升**: 99% → 99.9%
- **成本节省**: 提前发现问题，避免大规模故障

---

**实施优先级**: P0（生产必备）  
**预计耗时**: 1.5 工作日  
**依赖**: Prometheus、Grafana 已部署

---
