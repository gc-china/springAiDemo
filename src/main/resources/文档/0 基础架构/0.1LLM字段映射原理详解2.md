# LLM 如何理解 DTO 字段映射 - 深度解析

## 核心问题

**用户问题:** "马桶的库存是多少？"

**你的疑问:**

1. LLM 怎么知道 "马桶" 对应 DTO 的哪个字段？
2. 如果接口需要商品ID，但用户说的是商品名称怎么办？
3. 如果需要多个条件怎么办？

## 答案：JSON Schema 的魔法

### 1. LLM 看到的不是你的 Java 代码，而是 JSON Schema

当你定义这样的 DTO：

```java
public record ProductQueryRequest(
    @JsonPropertyDescription("产品名称，例如：智能马桶、洗脸盆")
    String productName,
    
    @JsonPropertyDescription("仓库区域代码，可选。默认查询主仓")
    String regionCode
) {}
```

**Spring AI 会自动生成并发送给 LLM 的 JSON Schema：**

```json
{
  "name": "queryInventory",
  "description": "高级库存查询工具，支持按区域和数量筛选",
  "parameters": {
    "type": "object",
    "properties": {
      "productName": {
        "type": "string",
        "description": "产品名称，例如：智能马桶、洗脸盆"
      },
      "regionCode": {
        "type": "string",
        "description": "仓库区域代码，可选。默认查询主仓"
      }
    },
    "required": ["productName"]
  }
}
```

### 2. LLM 的推理过程

```
用户输入: "马桶的库存是多少？"
    ↓
LLM 思考过程:
1. 用户想查询库存
2. 我有一个工具叫 "queryInventory"
3. 这个工具需要参数:
   - productName (必填): "产品名称，例如：智能马桶、洗脸盆"
   - regionCode (可选): "仓库区域代码"
4. 用户说的 "马桶" 明显是产品名称
5. 用户没有提到区域，所以 regionCode 不填

LLM 输出:
{
  "name": "queryInventory",
  "arguments": {
    "productName": "马桶"
  }
}
```

**关键点:** `@JsonPropertyDescription` 中的描述文字是 LLM 理解字段含义的**唯一依据**！

---

## 场景1: 接口需要 ID，但用户说的是名称

### 问题场景

```java
// 你的接口需要商品ID
public record ProductQueryRequest(
    @JsonPropertyDescription("商品ID，例如：PROD-001")
    String productId
) {}
```

**用户问:** "马桶的库存是多少？"

### 解决方案A: 两步工具调用（推荐）

定义两个工具，让 LLM 自动编排：

```java
// 工具1: 根据名称查询ID
@Bean
@Description("根据产品名称查询产品ID")
public Function<ProductNameRequest, ProductIdResult> findProductId() {
    return request -> {
        String name = request.productName();
        // 模拟数据库查询
        String id = switch (name) {
            case "马桶" -> "PROD-001";
            case "洗脸盆" -> "PROD-002";
            default -> null;
        };
        return new ProductIdResult(id, name);
    };
}

// 工具2: 根据ID查询库存
@Bean
@Description("根据产品ID查询库存数量")
public Function<ProductIdRequest, Integer> queryStockById() {
    return request -> {
        return stockService.getStock(request.productId());
    };
}
```

**LLM 的自动编排:**

```
用户: "马桶的库存是多少？"
    ↓
LLM 思考: 我需要先找到马桶的ID
    ↓
调用工具1: findProductId({"productName": "马桶"})
    ↓
得到结果: {"productId": "PROD-001", "productName": "马桶"}
    ↓
LLM 继续思考: 现在我有ID了，可以查库存了
    ↓
调用工具2: queryStockById({"productId": "PROD-001"})
    ↓
得到结果: 75
    ↓
LLM 回复用户: "马桶的库存是 75 件"
```

### 解决方案B: 支持多种输入方式

```java
public record ProductQueryRequest(
    @JsonPropertyDescription("商品ID，例如：PROD-001。如果不知道ID，可以不填")
    String productId,
    
    @JsonPropertyDescription("商品名称，例如：马桶。如果已知ID，可以不填")
    String productName
) {}

@Bean
@Description("查询商品库存。可以通过商品ID或商品名称查询")
public Function<ProductQueryRequest, Integer> queryStock() {
    return request -> {
        String id = request.productId();
        String name = request.productName();
        
        // 如果只有名称，先转换为ID
        if (id == null && name != null) {
            id = nameToIdMapping.get(name);
        }
        
        if (id == null) {
            throw new IllegalArgumentException("必须提供商品ID或名称");
        }
        
        return stockService.getStock(id);
    };
}
```

**LLM 的处理:**

```
用户: "马桶的库存是多少？"
    ↓
LLM 看到工具描述: "可以通过商品ID或商品名称查询"
    ↓
LLM 思考: 用户说的是名称，我填 productName 字段
    ↓
调用: queryStock({"productName": "马桶"})
    ↓
你的代码内部转换: "马桶" -> "PROD-001"
```

---

## 场景2: 需要多个条件

### 示例：复杂的库存查询

```java
public record AdvancedStockQueryRequest(
    @JsonProperty(required = true)
    @JsonPropertyDescription("商品名称或ID，必填")
    String product,
    
    @JsonPropertyDescription("仓库区域，可选。例如：华东、华北")
    String region,
    
    @JsonPropertyDescription("库存阈值，只返回库存大于此值的结果。可选")
    Integer minStock,
    
    @JsonPropertyDescription("是否包含预留库存。可选，默认false")
    Boolean includeReserved
) {}

@Bean
@Description("高级库存查询。支持按区域、库存阈值等多条件筛选")
public Function<AdvancedStockQueryRequest, StockResult> advancedQuery() {
    return request -> {
        // 处理所有条件
        String product = request.product();
        String region = request.region() != null ? request.region() : "全国";
        int minStock = request.minStock() != null ? request.minStock() : 0;
        boolean reserved = request.includeReserved() != null ? request.includeReserved() : false;
        
        return stockService.query(product, region, minStock, reserved);
    };
}
```

### LLM 如何处理多条件

**用户问题1:** "查一下马桶的库存"

```json
{
  "product": "马桶"
  // 其他字段不填，使用默认值
}
```

**用户问题2:** "华东地区马桶库存大于50的有多少"

```json
{
  "product": "马桶",
  "region": "华东",
  "minStock": 50
}
```

**用户问题3:** "包括预留库存，查一下华北的洗脸盆"

```json
{
  "product": "洗脸盆",
  "region": "华北",
  "includeReserved": true
}
```

**关键:** LLM 会根据用户的自然语言，**智能提取**所有提到的条件，并映射到对应的字段！

---

## 最佳实践总结

### 1. 字段描述要详细且具体

❌ **不好的描述:**

```java
@JsonPropertyDescription("产品")
String product;
```

✅ **好的描述:**

```java
@JsonPropertyDescription("产品名称或产品ID。例如：'智能马桶' 或 'PROD-001'")
String product;
```

### 2. 说明字段的必填性和默认值

```java
@JsonPropertyDescription("仓库区域代码，可选。不填则查询所有区域的总库存")
String region;
```

### 3. 提供示例值

```java
@JsonPropertyDescription("订单状态。可选值：'PENDING'(待处理)、'SHIPPED'(已发货)、'DELIVERED'(已送达)")
String status;
```

### 4. 工具级别的描述也很重要

```java
@Bean
@Description("查询商品库存。支持通过商品名称或ID查询，可选按区域筛选。返回实时库存数量")
public Function<StockRequest, Integer> queryStock() { ... }
```

---

## 核心原理总结

1. **LLM 不看 Java 代码**，只看 JSON Schema
2. **字段映射靠描述文字**，不是靠字段名
3. **LLM 会自动推理**用户意图和字段的对应关系
4. **多条件查询**：LLM 会提取用户提到的所有条件
5. **ID vs 名称**：要么支持两种输入，要么用两步工具调用

**记住:** `@JsonPropertyDescription` 是你和 LLM 沟通的桥梁，写得越清楚，LLM 理解得越准确！
