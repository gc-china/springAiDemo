# Function Calling 高级架构方案深度解析：智能仓储助手实战

本文档通过一个真实的**智能仓储助手**场景，深入剖析四种 Function Calling 高级方案的原理、适用性及实现细节。

---

## 方案一：前置意图识别 (NLU) —— "闪电快手"

### 🎬 场景故事

用户是仓库管理员，每天要重复几百次开关灯的操作。

* **用户说**: "把A区灯打开"
* **用户说**: "把B区灯关掉"
* **用户说**: "查询A区当前温度"

### ❌ 如果直接用 LLM (痛点)

1. **慢**: 每次开关灯都要等 LLM 思考 1-2 秒，管理员会疯掉。
2. **贵**: 每天几千次调用，Token 费用惊人。
3. **大材小用**: 开关灯这种死板的指令，不需要 LLM 的"智慧"。

### ✅ 方案原理：路由器模式

在请求到达 LLM 之前，设立一个**"快速通道"**。就像高速公路的 ETC 通道。

* **原理**: 使用正则表达式或轻量级 NLP 模型（如 BERT 意图分类），毫秒级判断用户意图。
* **流程**:
    1. 用户输入 -> **网关拦截**
    2. 网关判断: 包含 "开灯" / "关灯" 关键字?
    3. **是** -> 提取地点 (A区/B区) -> **直接调用硬件接口** -> 返回 "已执行"
    4. **否** -> 放行给 LLM 处理复杂问题 (如 "分析一下最近库存周转率")

### 💡 核心价值

**极速响应 + 零成本**。把 80% 的高频简单指令拦截在 LLM 之外。

---

## 方案二：前端表单辅助 (Client Forms) —— "填表专家"

### 🎬 场景故事

管理员需要录入一个新的入库单。

* **用户说**: "我要录入一批货，是联想的电脑，大概50台，放在C区，供应商是..."

### ❌ 如果直接用 LLM (痛点)

1. **容易漏**: "供应商是谁？联系人是谁？入库类型是采购还是退货？" LLM 需要反反复复问好几轮才能凑齐参数。
2. **容易错**: 用户说 "50台"，LLM 可能提取成字符串 "50" 还是数字 `50`？
3. **体验差**: 打字录入复杂信息非常累。

### ✅ 方案原理：UI 降级策略

LLM 不负责提取复杂参数，只负责**"唤起"**最适合的 UI 界面。

* **原理**: 自然语言适合**表达意图**，UI 表单适合**录入数据**。各取所长。
* **流程**:
    1. 用户: "我要入库"
    2. LLM: 识别意图是 `CREATE_ENTRY_ORDER`。
    3. LLM: 返回指令 `{"action": "OPEN_FORM", "formId": "entry_order"}`。
    4. 前端: 弹出一个标准的入库单表格。
    5. 用户: 在表格里点选、输入，点击"提交"。
    6. 前端: **直接调用后端 API** (绕过 LLM)。

### 💡 核心价值

**100% 准确率 + 高效录入**。解决复杂参数收集的难题。

---

## 方案三：人机协同确认 (Human-in-the-loop) —— "安全卫士" (⭐重点)

### 🎬 场景故事

管理员发出一项调拨指令。

* **用户说**: "把上海仓所有的 iPhone 15 全部发到北京仓，急用！"

### ❌ 如果直接用 LLM (痛点)

1. **幻觉风险**: LLM 可能把 "iPhone 15" 理解成了 "iPhone 15 Pro"。
2. **理解偏差**: "全部" 是多少？库存里有 10000 台，真的要全发吗？
3. **后果严重**: 一旦执行，几千万的货就发走了，运费损失巨大，且难以撤回。

### ✅ 方案原理：两阶段提交 (Two-Phase Commit)

借鉴数据库事务的思想，将操作分为 **"准备(Prepare)"** 和 **"提交(Commit)"** 两个阶段。

#### 阶段一：起草 (Drafting)

1. LLM 分析用户指令。
2. LLM 提取参数: `product="iPhone 15", from="上海", to="北京", quantity="ALL"`。
3. LLM 调用工具 `transferStock`。
4. **后端拦截**: 发现这是一个**敏感操作** (Write Operation)。
5. 后端查询当前状态: "上海仓 iPhone 15 当前库存 5000 台"。
6. 后端**不执行调拨**，而是生成一个 **"确认单对象"** 返回给 LLM/前端。

#### 阶段二：确认 (Confirmation)

1. 系统向用户展示确认卡片：
   > **⚠️ 调拨确认**
   > * 商品: iPhone 15
   > * 源仓库: 上海
   > * 目标仓: 北京
   > * 数量: **5000 台** (系统自动计算出的"全部")
   > * **[确认执行]**  **[取消]**
2. 用户检查发现没错，点击 **[确认执行]**。
3. 系统携带 `confirmed=true` 标记，再次调用接口，真正执行数据库更新。

### 💻 代码实现逻辑

```java
public class TransferTool {
    public TransferResult transfer(TransferRequest req) {
        // 1. 检查确认标记
        if (!req.isConfirmed()) {
            // 2. 预计算影响 (Dry Run)
            int stock = stockService.checkStock(req.getProduct(), req.getFrom());
            
            // 3. 返回确认请求，而不是执行结果
            return new TransferResult(
                "PENDING", 
                "⚠️ 危险操作确认：您即将把上海仓全部 " + stock + " 台 iPhone 15 发往北京。请确认？"
            );
        }
        
        // 4. 用户确认后，真正执行
        stockService.doTransfer(req);
        return new TransferResult("SUCCESS", "已执行调拨");
    }
}
```

### 💡 核心价值

**兜底安全**。在 AI 和 关键业务之间加一道"防盗门"，防止 AI 犯傻导致业务灾难。

---

## 方案四：模糊搜索与参数矫正 (Fuzzy Search) —— "智能翻译官" (⭐重点)

### 🎬 场景故事

管理员查询库存，但他记不清准确的商品名称。

* **数据库里有**: "Apple iPhone 15 Pro Max 256G 深空灰" (ID: P-001)
* **用户说**: "查一下苹果15的库存"

### ❌ 如果直接用 LLM (痛点)

1. **参数不准**: LLM 提取出 `productName="苹果15"`。
2. **查询失败**: 数据库里没有叫 "苹果15" 的商品，SQL 查询返回空。
3. **回复生硬**: 系统回复 "未找到商品：苹果15"。用户体验极差，觉得系统很笨。

### ✅ 方案原理：中间件拦截与矫正

在 LLM 提取的"自然语言参数"和 数据库需要的"精确参数"之间，加一个 **"翻译层"**。

#### 流程深度拆解

1. **LLM 提取**: 得到 `arg="苹果15"`。
2. **AOP 拦截**: 在进入 `queryStock` 方法前，拦截这个参数。
3. **搜索引擎召回 (Recall)**:
    * 使用 ElasticSearch 或 简单的模糊匹配 (`LIKE %苹果15%`)。
    * 去数据库里找最像的商品。
4. **决策逻辑 (Decision Making)**:
    * **情况 A (命中)**: 找到了 "iPhone 15"。
        * 动作: 偷偷把参数 `arg="苹果15"` 替换为 ID `arg="P-001"`。
        * 结果: 接口调用成功，用户觉得系统很智能。
    * **情况 B (歧义)**: 找到了 "iPhone 15" 和 "iPhone 15 Pro"。
        * 动作: **打断调用**。直接返回错误信息给 LLM："找到了多个商品(iPhone 15, iPhone 15 Pro)，请问用户是哪一个？"
        * 结果: LLM 会转述这个问题给用户："您是指 iPhone 15 还是 15 Pro？"
    * **情况 C (无果)**: 啥也没找到。
        * 动作: 返回错误。

### 💻 代码实现逻辑 (AOP 切面)

```java
@Around("execution(* StockService.query(..))")
public Object correctArgs(ProceedingJoinPoint joinPoint) {
    // 1. 拿到 LLM 传来的原始参数 "苹果15"
    String rawName = (String) joinPoint.getArgs()[0];
    
    // 2. 去数据库/ES 搜一下
    List<Product> matches = searchService.search(rawName);
    
    // 3. 只有一个匹配，直接替换！
    if (matches.size() == 1) {
        String realId = matches.get(0).getId(); // "P-001"
        // 偷梁换柱：用 ID 替换掉原来的名称
        return joinPoint.proceed(new Object[]{realId});
    }
    
    // 4. 多个匹配，抛出异常让 LLM 去问用户
    if (matches.size() > 1) {
        return "找到多个商品：" + matches + "，请明确具体是哪一个。";
    }
    
    return "没找到这个商品。";
}
```

### 💡 核心价值

**鲁棒性 (Robustness)**。弥合了"人类模糊语言"与"机器精确数据"之间的鸿沟。让系统看起来"听得懂人话"。

---

## 🏆 总结

| 方案      | 别名    | 核心作用   | 一句话总结            |
|:--------|:------|:-------|:-----------------|
| **方案一** | 闪电快手  | **分流** | 简单的自己做，难的给 AI 做。 |
| **方案二** | 填表专家  | **降级** | 复杂的填表工作，交给 UI 做。 |
| **方案三** | 安全卫士  | **风控** | 危险的操作，确认了再做。     |
| **方案四** | 智能翻译官 | **矫正** | 模糊的话，翻译准了再做。     |

在你的项目中：

* **查库存**：请务必使用 **方案四**，解决用户记不住全名的问题。
* **发货/调拨**：请务必使用 **方案三**，防止发错货。
